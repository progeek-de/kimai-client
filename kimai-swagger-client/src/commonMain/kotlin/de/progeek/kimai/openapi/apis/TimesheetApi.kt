/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package de.progeek.kimai.openapi.apis

import de.progeek.kimai.openapi.models.GetRestartTimesheetGetRequest
import de.progeek.kimai.openapi.models.PatchAppApiActivityMetaRequest
import de.progeek.kimai.openapi.models.TimesheetCollection
import de.progeek.kimai.openapi.models.TimesheetCollectionExpanded
import de.progeek.kimai.openapi.models.TimesheetEditForm
import de.progeek.kimai.openapi.models.TimesheetEntity

import de.progeek.kimai.openapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class TimesheetApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Delete an existing timesheet record
     * 
     * @param id Timesheet record ID to delete
     * @return void
     */
    open suspend fun deleteDeleteTimesheet(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/timesheets/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Returns the collection of active timesheet records
     * 
     * @return kotlin.collections.List<TimesheetCollectionExpanded>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getActiveTimesheet(): HttpResponse<kotlin.collections.List<TimesheetCollectionExpanded>> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/timesheets/active",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetActiveTimesheetResponse>().map { value }
    }

    @Serializable
    private class GetActiveTimesheetResponse(val value: List<TimesheetCollectionExpanded>) {
        @Serializer(GetActiveTimesheetResponse::class)
        companion object : KSerializer<GetActiveTimesheetResponse> {
            private val serializer: KSerializer<List<TimesheetCollectionExpanded>> = serializer<List<TimesheetCollectionExpanded>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetActiveTimesheetResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetActiveTimesheetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Returns one timesheet record
     * 
     * @param id Timesheet record ID to fetch
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getGetTimesheet(id: kotlin.String): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/timesheets/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Returns a collection of timesheet records (which are visible to the user)
     * 
     * @param user User ID to filter timesheets. Needs permission &#39;view_other_timesheet&#39;, pass &#39;all&#39; to fetch data for all user (default: current user) (optional)
     * @param users List of user IDs to filter, e.g.: users[]&#x3D;1&amp;users[]&#x3D;2 (ignored if user&#x3D;all) (optional, default to arrayListOf())
     * @param customer Customer ID to filter timesheets (optional)
     * @param customers List of customer IDs to filter, e.g.: customers[]&#x3D;1&amp;customers[]&#x3D;2 (optional, default to arrayListOf())
     * @param project Project ID to filter timesheets (optional)
     * @param projects List of project IDs to filter, e.g.: projects[]&#x3D;1&amp;projects[]&#x3D;2 (optional, default to arrayListOf())
     * @param activity Activity ID to filter timesheets (optional)
     * @param activities List of activity IDs to filter, e.g.: activities[]&#x3D;1&amp;activities[]&#x3D;2 (optional, default to arrayListOf())
     * @param page The page to display, renders a 404 if not found (default: 1) (optional)
     * @param size The amount of entries for each page (default: 50) (optional)
     * @param tags List of tag names, e.g. tags[]&#x3D;bar&amp;tags[]&#x3D;foo (optional, default to arrayListOf())
     * @param orderBy The field by which results will be ordered. Allowed values: id, begin, end, rate (default: begin) (optional)
     * @param order The result order. Allowed values: ASC, DESC (default: DESC) (optional)
     * @param begin Only records after this date will be included (format: HTML5) (optional)
     * @param end Only records before this date will be included (format: HTML5) (optional)
     * @param exported Use this flag if you want to filter for export state. Allowed values: 0&#x3D;not exported, 1&#x3D;exported (default: all) (optional)
     * @param active Filter for running/active records. Allowed values: 0&#x3D;stopped, 1&#x3D;active (default: all) (optional)
     * @param billable Filter for non-/billable records. Allowed values: 0&#x3D;non-billable, 1&#x3D;billable (default: all) (optional)
     * @param full Allows to fetch fully serialized objects including subresources. Allowed values: true (default: false) (optional)
     * @param term Free search term (optional)
     * @param modifiedAfter Only records changed after this date will be included (format: HTML5). Available since Kimai 1.10 and works only for records that were created/updated since then. (optional)
     * @return kotlin.collections.List<TimesheetCollection>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getGetTimesheets(user: kotlin.String? = null, users: kotlin.collections.List<kotlin.Any>? = arrayListOf(), customer: kotlin.String? = null, customers: kotlin.collections.List<kotlin.Any>? = arrayListOf(), project: kotlin.String? = null, projects: kotlin.collections.List<kotlin.Any>? = arrayListOf(), activity: kotlin.String? = null, activities: kotlin.collections.List<kotlin.Any>? = arrayListOf(), page: kotlin.String? = null, size: kotlin.String? = null, tags: kotlin.collections.List<kotlin.Any>? = arrayListOf(), orderBy: kotlin.String? = null, order: kotlin.String? = null, begin: kotlin.String? = null, end: kotlin.String? = null, exported: kotlin.String? = null, active: kotlin.String? = null, billable: kotlin.String? = null, full: kotlin.String? = null, term: kotlin.String? = null, modifiedAfter: kotlin.String? = null): HttpResponse<kotlin.collections.List<TimesheetCollection>> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        user?.apply { localVariableQuery["user"] = listOf("$user") }
        users?.apply { localVariableQuery["users[]"] = toMultiValue(this, "multi") }
        customer?.apply { localVariableQuery["customer"] = listOf("$customer") }
        customers?.apply { localVariableQuery["customers[]"] = toMultiValue(this, "multi") }
        project?.apply { localVariableQuery["project"] = listOf("$project") }
        projects?.apply { localVariableQuery["projects[]"] = toMultiValue(this, "multi") }
        activity?.apply { localVariableQuery["activity"] = listOf("$activity") }
        activities?.apply { localVariableQuery["activities[]"] = toMultiValue(this, "multi") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        size?.apply { localVariableQuery["size"] = listOf("$size") }
        tags?.apply { localVariableQuery["tags[]"] = toMultiValue(this, "multi") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("$orderBy") }
        order?.apply { localVariableQuery["order"] = listOf("$order") }
        begin?.apply { localVariableQuery["begin"] = listOf("$begin") }
        end?.apply { localVariableQuery["end"] = listOf("$end") }
        exported?.apply { localVariableQuery["exported"] = listOf("$exported") }
        active?.apply { localVariableQuery["active"] = listOf("$active") }
        billable?.apply { localVariableQuery["billable"] = listOf("$billable") }
        full?.apply { localVariableQuery["full"] = listOf("$full") }
        term?.apply { localVariableQuery["term"] = listOf("$term") }
        modifiedAfter?.apply { localVariableQuery["modified_after"] = listOf("$modifiedAfter") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/timesheets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetGetTimesheetsResponse>().map { value }
    }

    @Serializable
    private class GetGetTimesheetsResponse(val value: List<TimesheetCollection>) {
        @Serializer(GetGetTimesheetsResponse::class)
        companion object : KSerializer<GetGetTimesheetsResponse> {
            private val serializer: KSerializer<List<TimesheetCollection>> = serializer<List<TimesheetCollection>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetGetTimesheetsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetGetTimesheetsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Returns the collection of recent user activities
     * 
     * @param begin Only records after this date will be included. Default: today - 1 year (format: HTML5) (optional)
     * @param size The amount of entries (default: 10) (optional)
     * @return kotlin.collections.List<TimesheetCollectionExpanded>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getRecentTimesheet(begin: kotlin.String? = null, size: kotlin.String? = null): HttpResponse<kotlin.collections.List<TimesheetCollectionExpanded>> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        begin?.apply { localVariableQuery["begin"] = listOf("$begin") }
        size?.apply { localVariableQuery["size"] = listOf("$size") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/timesheets/recent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetRecentTimesheetResponse>().map { value }
    }

    @Serializable
    private class GetRecentTimesheetResponse(val value: List<TimesheetCollectionExpanded>) {
        @Serializer(GetRecentTimesheetResponse::class)
        companion object : KSerializer<GetRecentTimesheetResponse> {
            private val serializer: KSerializer<List<TimesheetCollectionExpanded>> = serializer<List<TimesheetCollectionExpanded>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetRecentTimesheetResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetRecentTimesheetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Restarts a previously stopped timesheet record for the current user
     * 
     * @param id Timesheet record ID to restart
     * @param getRestartTimesheetGetRequest  (optional)
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getRestartTimesheetGet(id: kotlin.String, getRestartTimesheetGetRequest: GetRestartTimesheetGetRequest? = null): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = getRestartTimesheetGetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/timesheets/{id}/restart".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Stops an active timesheet record.
     * This route is available via GET and PATCH, as users over and over again run into errors when stopping. Likely caused by a slow JS engine and a fast-click after page reload.
     * @param id Timesheet record ID to stop
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getStopTimesheetGet(id: kotlin.String): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/timesheets/{id}/stop".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Sets the value of a meta-field for an existing timesheet.
     * 
     * @param id Timesheet record ID to set the meta-field value for
     * @param patchAppApiActivityMetaRequest  (optional)
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchAppApiTimesheetMeta(id: kotlin.String, patchAppApiActivityMetaRequest: PatchAppApiActivityMetaRequest? = null): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = patchAppApiActivityMetaRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/api/timesheets/{id}/meta".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Duplicates an existing timesheet record
     * 
     * @param id Timesheet record ID to duplicate
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchDuplicateTimesheet(id: kotlin.String): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/api/timesheets/{id}/duplicate".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Switch the export state of a timesheet record to (un-)lock it
     * 
     * @param id Timesheet record ID to switch export state
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchExportTimesheet(id: kotlin.String): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/api/timesheets/{id}/export".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update an existing timesheet record
     * Update an existing timesheet record, you can pass all or just a subset of the attributes.
     * @param id Timesheet record ID to update
     * @param timesheetEditForm 
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchPatchTimesheet(id: kotlin.String, timesheetEditForm: TimesheetEditForm): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = timesheetEditForm

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/api/timesheets/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Restarts a previously stopped timesheet record for the current user
     * 
     * @param id Timesheet record ID to restart
     * @param getRestartTimesheetGetRequest  (optional)
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchRestartTimesheet(id: kotlin.String, getRestartTimesheetGetRequest: GetRestartTimesheetGetRequest? = null): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = getRestartTimesheetGetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/api/timesheets/{id}/restart".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Stops an active timesheet record.
     * This route is available via GET and PATCH, as users over and over again run into errors when stopping. Likely caused by a slow JS engine and a fast-click after page reload.
     * @param id Timesheet record ID to stop
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchStopTimesheet(id: kotlin.String): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/api/timesheets/{id}/stop".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Creates a new timesheet record
     * Creates a new timesheet record for the current user and returns it afterwards.
     * @param timesheetEditForm 
     * @param full Allows to fetch fully serialized objects including subresources (TimesheetExpanded). Allowed values: true (default: false) (optional)
     * @return TimesheetEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun postPostTimesheet(timesheetEditForm: TimesheetEditForm, full: kotlin.String? = null): HttpResponse<TimesheetEntity> {

        val localVariableAuthNames = listOf<String>("apiToken", "apiUser")

        val localVariableBody = timesheetEditForm

        val localVariableQuery = mutableMapOf<String, List<String>>()
        full?.apply { localVariableQuery["full"] = listOf("$full") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/timesheets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
